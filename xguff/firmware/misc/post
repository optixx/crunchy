Hi, everyone!

My adaptation of USRP code for a conceptually related (rx-only)
project has gone pretty well.  I get a reliable 33 MB/s sustained
data transfer from the FPGA to the host (same results on an AMD64
desktop and Intel Centrino laptop).  The hardware platform is an
Avnet Virtex-4 Eval board.  I hacked up Verilog code for the FPGA,
8051 code, and have used the host-side code almost unchanged.  Let
me report on the similarities and differences, and then ask a few
questions.

FPGA code:

Since this isn't an Altera chip, the megafunctions are useless.
I replaced the FIFO in rx_buffer.v with one from OpenCores:
generic_fifo_dc_gray.v + generic_dpram.v.  I also stripped out
the 8-way multiplexer, since IMHO that belongs closer to the
application-specific layer, and in my case the (12-way) multiplexing
is done more efficiently further upstream.

My implementation of serial I/O is quite different from the USRP,
derived from the different style of modularity.  It is more convenient
for me to pass an address/data/strobe bus to each module, and let
them decode what addresses to store in what register.  The top level
has about eight lines of code for serial->parallel conversion of the
SPI bus, synchronize and falling-edge detect on the SEN_FPGA pin to
trigger a write.  All my registers are defined as 32 bits wide.

I can simulate, I think realistically, the data transfer process
from the data source through the FIFO to the GPIF port, all using
Icarus Verilog.

8051 code:

It took a while to understand what I was doing.  Thanks for your
help, Eric and Matt.  My FPGA is programmed over JTAG, which has
some extra features compared with a slave serial write.  Then
there are little things, like a Xilinx needs to be released from
reset before programming, not after.

I temporarily ripped out the I2C code to have a place to hang my
JTAG probe functions.  Among other things, that meant I didn't have
to touch usrp_commands.h, and I could use the existing usrper i2c_read
mode to report the JTAG ID codes!

I have in mind playing with the JTAG user programmability in the
Xilinx chips to set registers over that interface, instead of through
SPI.  I think that would be the ticket to making a usable system with
the 56-pin variant of the CY7C68013.

I recoded read_byte_msb and write_byte_msb in spi.c to save 110 bytes
of 8051 code space.  The latter routine is tested, works fine.  Anyone
interested?

I had to hack usrp_gpif.c to keep CTL3 high.  That's the pin Avnet
chose to control the FPGA reset line.  :-p
Touching up code generated by proprietaty software and labeled
"DO NOT EDIT ..." is less than satisfying, so I played around with
a compiler (previously posted) to generate the GPIF WaveData tables.
I suppose now that I have everything working, I can finish this up to
include the FlowStates generator, and actually use this in my builds.

Questions:

Can someone reserve a Free Software Folks USB product ID for me?

Shall I start the wholesale changes to usrp_commands.h and usrper
to add JTAG I/O routines?  Or would it make just as much sense to
special-case a block of I2C addresses in lib/i2c.c?  I'd like to
make the minimum required code changes from USRP, to make it easier
to track bug fixes etc. from USRP.  Is anyone else interested in
JTAG hooks?

Is there a reason half the .v files in CVS fpga/sdr_lib are marked
executable?

Would anyone else use an FX2 WaveData compiler if I polished it up?

     - Larry
